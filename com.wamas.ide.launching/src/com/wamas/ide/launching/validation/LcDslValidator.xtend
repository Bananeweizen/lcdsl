/*
 * generated by Xtext 2.10.0
 */
package com.wamas.ide.launching.validation

import com.wamas.ide.launching.generator.LcDslGenerator
import com.wamas.ide.launching.lcDsl.ExecutionEnvironment
import com.wamas.ide.launching.lcDsl.ExistingPath
import com.wamas.ide.launching.lcDsl.LaunchConfig
import com.wamas.ide.launching.lcDsl.LcDslPackage
import com.wamas.ide.launching.lcDsl.PluginWithVersion
import com.wamas.ide.launching.lcDsl.Project
import com.wamas.ide.launching.lcDsl.StringWithVariables
import java.io.File
import java.util.List
import java.util.Set
import org.eclipse.core.internal.variables.StringVariableManager
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.jdt.core.JavaCore
import org.eclipse.jdt.launching.JavaRuntime
import org.eclipse.pde.core.plugin.IMatchRules
import org.eclipse.pde.core.plugin.PluginRegistry
import org.eclipse.xtext.validation.Check

import static com.wamas.ide.launching.lcDsl.LaunchConfigType.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LcDslValidator extends AbstractLcDslValidator {

	public static val PLUGIN_NOT_ALLOWED = 'plugin.not.allowed'
	public static val INHERITANCE_TYPE_MISMATCH = 'inheritance.type.mismatch'

	private LcDslPackage LC = LcDslPackage.eINSTANCE

	// map config features to types where this feature is allowed. not mentioned features are allowed on all types.
	private val allowedFeatures = newHashMap(
		// modifiers on config
		LC.launchConfig_NoConsole -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_NoValidate -> #{ECLIPSE, RAP},
		LC.launchConfig_SwInstallSupport -> #{ECLIPSE},
		LC.launchConfig_ReplaceEnv -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_StopInMain -> #{JAVA},
		// single appearance features
		LC.launchConfig_Clears -> #{ECLIPSE, RAP},
		LC.launchConfig_Workspace -> #{ECLIPSE, RAP},
		LC.launchConfig_WorkingDir -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_Memory -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_Project -> #{JAVA},
		LC.launchConfig_MainClass -> #{JAVA},
		LC.launchConfig_Application -> #{ECLIPSE},
		LC.launchConfig_Product -> #{ECLIPSE},
		LC.launchConfig_Redirect -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_ExecEnv -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_ConfigIniTemplate -> #{ECLIPSE},
		LC.launchConfig_JavaMainSearch -> #{JAVA},
		LC.launchConfig_ServletConfig -> #{RAP},
		// multi appearance features
		LC.launchConfig_Plugins -> #{ECLIPSE, RAP},
		LC.launchConfig_Ignore -> #{ECLIPSE, RAP},
		LC.launchConfig_GroupMembers -> #{GROUP},
		LC.launchConfig_VmArgs -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_ProgArgs -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_EnvVars -> #{ECLIPSE, RAP, JAVA},
		LC.launchConfig_Traces -> #{ECLIPSE, RAP}
	)

	private val requiredFeatures = newHashMap(
		ECLIPSE -> #{
			#{LC.launchConfig_Application, LC.launchConfig_Product},
			#{LC.launchConfig_Workspace},
			#{LC.launchConfig_Plugins}
		},
		RAP -> #{
			#{LC.launchConfig_ServletConfig},
			#{LC.launchConfig_Plugins}
		},
		JAVA -> #{
			#{LC.launchConfig_MainClass},
			#{LC.launchConfig_Project}
		},
		GROUP -> #{
			#{LC.launchConfig_GroupMembers}
		}
	)

	@Check
	def checkSpecifics(LaunchConfig lc) {
		// validate supported attributes
		for (entry : allowedFeatures.entrySet) {
			val feature = entry.key
			val types = entry.value

			if (!types.contains(lc.type)) {
				// not allowed to have it, check
				val e = lc.eGet(feature)

				if (e != null) {
					// it is set, check for empty collection
					if (e instanceof EList<?>) {
						if (!e.empty) {
							error("unsupported attribute for type " + lc.type, feature)
						}
					} else if (e instanceof Boolean) {
						if (e.equals(Boolean.TRUE))
							error("unsupported attribute for type " + lc.type, feature)
					} else {
						error("unsupported attribute for type " + lc.type, feature)
					}
				}
			}
		}

		val required = requiredFeatures.get(lc.type)
		if (required == null) {
			error("unsupported launch configuration type - validation not implemented", LC.launchConfig_Type)
		} else {
			for (alternatives : required) {
				var anySet = false
				for (feature : alternatives) {
					val e = lc.eGet(feature)
					if (e != null) {
						if (e instanceof EList<?>) {
							if (!e.empty)
								anySet = true
						} else {
							anySet = true
						}
					}
				}

				if (!anySet) {
					// missing required feature.
					error("missing required attribute: " + alternatives.simpleNames, LC.launchConfig_Name)
				}
			}
		}
	}

	def List<String> simpleNames(Set<? extends EStructuralFeature> features) {
		val names = newArrayList()

		features.forEach[f|names.add(f.name)]

		return names
	}

	@Check
	def checkInheritance(LaunchConfig lc) {
		// check that inheriting from another config of same type only
		if (lc.superConfig != null && lc.superConfig.type != lc.type) {
			error("Super launch configuration has a different type", LC.launchConfig_SuperConfig)
		}
	}

	@Check
	def checkProjectExists(Project p) {
		val prj = ResourcesPlugin.workspace.root.getProject(p.name);
		if (prj == null || !prj.exists) {
			warning("Project " + p.name + " does not exist in the workspace", p, LC.project_Name)
		} else if (!prj.open) {
			warning("Project " + p.name + " is closed", p, LC.project_Name)
		}
	}

	@Check
	def checkPluginExists(PluginWithVersion p) {
		if (p.name == null)
			return;

		val bundle = PluginRegistry.findModel(p.name, p.version, IMatchRules.PERFECT, null)

		if (bundle == null) {
			if (PluginRegistry.findModel(p.name, null, IMatchRules.NONE, null) != null) {
				warning("Bundle " + p.name + " does not exist in version " + p.version, p,
					LC.pluginWithVersion_Version);
			} else {
				warning("Bundle " + p.name + " does not exist in the workspace or the current target platform", p,
					LC.pluginWithVersion_Name);
			}
		}
	}

	@Check
	def checkMainType(LaunchConfig cfg) {
		if (cfg.type == JAVA && cfg.project != null && !cfg.project.name.empty && cfg.mainClass != null &&
			!cfg.mainClass.name.empty) {
			val prj = ResourcesPlugin.workspace.root.getProject(cfg.project.name);
			if (prj != null && prj.exists && prj.open) {
				val jp = JavaCore.create(prj)
				if (!jp.exists) {
					error("project " + cfg.project.name + " is not a java project", LC.launchConfig_Project)
					return
				}

				val type = jp.findType(cfg.mainClass.name, new NullProgressMonitor)
				if (type == null || !type.exists) {
					error("main type " + cfg.mainClass.name + " not found in class-path of " + cfg.project.name,
						LC.launchConfig_MainClass)
					return
				}

				if (!type.methods.exists[mainMethod]) {
					error("type " + cfg.mainClass.name + " does not contain a main method", LC.launchConfig_MainClass)
					return
				}
			}
		}
	}

	@Check
	def checkPathExists(ExistingPath p) {
		try {
			val f = new File(p.name.expanded);
			if (!f.exists) {
				warning("Path " + p.name + " does not exist", p, LC.path_Name)
			}
		} catch(CoreException e) {
			warning(e.message, LC.path_Name)
		}
	}

	@Check
	def checkSupportedType(LaunchConfig cfg) {
		if (!LcDslGenerator.isTypeSupported(cfg)) {
			warning("Unsupported configuration type in current setup, can not generate launch configuration",
				LC.launchConfig_Type)
		}
	}

	@Check
	def checkExecutionEnvironment(ExecutionEnvironment e) {
		if (e.name == null || e.name.empty)
			return

		val exe = JavaRuntime.getExecutionEnvironmentsManager().getEnvironment(e.name);
		if (exe == null) {
			error("cannot find execution environment " + e.name, LC.executionEnvironment_Name)
		} else if (exe.compatibleVMs.empty) {
			error("no compatible VMs available in the current configuration for " + e.name,
				LC.executionEnvironment_Name)
		} else if (exe.defaultVM == null) {
			warning("no default VM configured for execution environment " + e.name, LC.executionEnvironment_Name)
		}
	}
	
	/** only required for validation. raw value must be written into launch configurations to allow expansion at launch time */
	static def getExpanded(StringWithVariables original) {
		return StringVariableManager.^default.performStringSubstitution(original.value, true)
	}
	
}
