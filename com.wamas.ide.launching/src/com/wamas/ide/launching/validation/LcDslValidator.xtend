/*
 * generated by Xtext 2.10.0
 */
package com.wamas.ide.launching.validation

import com.wamas.ide.launching.generator.StandaloneLaunchConfigGenerator
import com.wamas.ide.launching.lcDsl.ExistingPath
import com.wamas.ide.launching.lcDsl.LaunchConfig
import com.wamas.ide.launching.lcDsl.LaunchConfigType
import com.wamas.ide.launching.lcDsl.LcDslPackage
import com.wamas.ide.launching.lcDsl.Plugin
import com.wamas.ide.launching.lcDsl.Project
import java.io.File
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.debug.core.DebugPlugin
import org.eclipse.pde.internal.core.PDECore
import org.eclipse.xtext.validation.Check
import org.osgi.framework.Version

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LcDslValidator extends AbstractLcDslValidator {
	
public static val PLUGIN_NOT_ALLOWED = 'plugin.not.allowed'
	public static val INHERITANCE_TYPE_MISMATCH = 'inheritance.type.mismatch'
	
	val launchMgr = DebugPlugin.^default.launchManager

	@Check
	def checkEclipseAndRapSpecific(LaunchConfig lc) {
		// check if plugin is used in plain java config
		if (lc.type == LaunchConfigType.ECLIPSE || lc.type == LaunchConfigType.RAP) {
			return;
		}

		if (!lc.plugins.empty) {
			error("Plugins not allowed for plain Java applications", LcDslPackage.eINSTANCE.launchConfig_Plugins)
		}

		if (!lc.ignore.empty) {
			error("Ignores not allowed for plain Java applications", LcDslPackage.eINSTANCE.launchConfig_Ignore)
		}

		if (lc.workspace != null) {
			error("Workspace is only valid for Eclipse and RAP launches", LcDslPackage.eINSTANCE.launchConfig_Workspace)
		}
	}

	@Check
	def checkGroupSpecific(LaunchConfig lc) {
		if (lc.type == LaunchConfigType.GROUP) {
			return;
		}

		if (!lc.groupMembers.empty) {
			error("Group members is only allowed for group launches", LcDslPackage.eINSTANCE.launchConfig_GroupMembers)
		}
	}

	@Check
	def checkJavaSpecific(LaunchConfig lc) {
		if (lc.type == LaunchConfigType.JAVA) {
			return;
		}

		if (lc.project != null) {
			error("Project may only be specified for java launches", LcDslPackage.eINSTANCE.launchConfig_Project)
		}
	}

	@Check
	def checkInheritance(LaunchConfig lc) {
		// check that inheriting from another config of same type only
		if (lc.superConfig != null && lc.superConfig.type != lc.type) {
			error("Super launch configuration has a different type", LcDslPackage.eINSTANCE.launchConfig_SuperConfig)
		}
	}

	@Check
	def checkProjectExists(Project p) {
		val prj = ResourcesPlugin.workspace.root.getProject(p.name);
		if (prj == null || !prj.exists) {
			warning("Project " + p.name + " does not exist in the workspace", p, LcDslPackage.eINSTANCE.project_Name)
		} else if (!prj.open) {
			warning("Project " + p.name + " is closed", p, LcDslPackage.eINSTANCE.project_Name)
		}
	}

	@Check
	def checkPluginExists(Plugin p) {
		if (p.name == null)
			return;

		// check current PDE state
		val state = PDECore.getDefault().getModelManager().getState().getState();
		state.resolve(true);

		var ver = null as Version;
		if (p.version != null && !p.version.empty) {
			ver = new Version(p.version);
		}

		val bundle = state.getBundle(p.name, ver);
		if (bundle == null) {
			if (state.getBundle(p.name, null) != null) {
				warning("Bundle " + p.name + " does not exist in version " + ver, p, LcDslPackage.eINSTANCE.plugin_Version);
			} else {
				warning("Bundle " + p.name + " does not exist in the workspace or the current target platform", p,
					LcDslPackage.eINSTANCE.plugin_Name);
			}
		}
	}

	@Check
	def checkPathExists(ExistingPath p) {
		// TODO: variable expansion
		val f = new File(p.name);
		if (!f.exists) {
			warning("Path " + p.name + " does not exist", p, LcDslPackage.eINSTANCE.path_Name)
		}
	}
	
	@Check
	def checkSupportedType(LaunchConfig cfg) {
		if(StandaloneLaunchConfigGenerator.getType(launchMgr, cfg.type) == null) {
			warning("Unsupported configuration type in current setup: " + cfg.type.getName, LcDslPackage.eINSTANCE.launchConfig_Type)
		}
	}
	
}
